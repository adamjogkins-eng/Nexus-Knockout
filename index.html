<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Nexus Knockout Pro - Ultimate Edition</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;900&display=swap');
        body { margin: 0; overflow: hidden; font-family: 'Orbitron', sans-serif; background: #000; user-select: none; -webkit-user-select: none; color: white; }
        canvas { display: block; }

        #overlay { position: absolute; inset: 0; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; z-index: 5; display: none; }

        #start-screen, #pause-screen, #matchmaking-screen {
            position: fixed; inset: 0; background: radial-gradient(circle at center, #0a0b14 0%, #000 100%);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 100; pointer-events: auto;
        }
        #pause-screen { display: none; background: rgba(0,0,0,0.92); backdrop-filter: blur(20px); }
        #matchmaking-screen { display: none; background: #000; }

        .char-grid { 
            display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; 
            margin-top: 15px; max-height: 45vh; overflow-y: auto; padding: 15px;
            background: rgba(255,255,255,0.02); border-radius: 15px; width: 85vw;
        }
        .char-card {
            background: rgba(255,255,255,0.05); border: 1px solid #333; border-radius: 6px;
            padding: 8px; text-align: center; cursor: pointer; transition: 0.2s; font-size: 9px;
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
        }
        .char-card:hover { border-color: #f1c40f; background: rgba(241, 196, 15, 0.1); transform: scale(1.05); }
        .locked { opacity: 0.3; filter: grayscale(1); cursor: not-allowed; border-style: dashed; }
        
        .hud-container { display: flex; justify-content: space-between; padding: 10px; align-items: flex-start; width: 100%; box-sizing: border-box; }
        .player-card {
            background: rgba(0, 0, 0, 0.85); padding: 10px 15px; border-radius: 12px;
            border-bottom: 4px solid #00d2ff; min-width: 120px; backdrop-filter: blur(10px);
            pointer-events: none;
        }
        .damage-val { font-size: 26px; font-weight: 900; color: #ff4d4d; margin: 2px 0; transition: transform 0.1s; }
        
        #pause-trigger { pointer-events: auto; cursor: pointer; text-align: center; padding: 5px 12px; background: rgba(255,255,255,0.1); border-radius: 20px; font-size: 10px; margin-top: 10px; }

        .sp-bar { width: 100%; height: 6px; background: #222; border-radius: 3px; overflow: hidden; margin-top: 5px; border: 1px solid #444; }
        .sp-fill { height: 100%; width: 0%; background: linear-gradient(90deg, #f1c40f, #ff9f43); transition: width 0.1s; }

        .controls { display: flex; justify-content: space-between; align-items: flex-end; padding: 20px; pointer-events: auto; }
        #joystick-outer { width: 85px; height: 85px; background: rgba(255,255,255,0.05); border-radius: 50%; border: 2px solid rgba(255,255,255,0.1); position: relative; touch-action: none; }
        #joystick-knob { width: 34px; height: 34px; background: #fff; border-radius: 50%; position: absolute; top: 25px; left: 25px; pointer-events: none; }
        
        .btn-group { display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; }
        .btn { width: 50px; height: 50px; border-radius: 50%; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.3); display: flex; align-items: center; justify-content: center; font-weight: bold; touch-action: none; font-size: 9px; }
        .btn:active { background: rgba(255,255,255,0.3); transform: scale(0.9); }
        .btn-sp { border-color: #f1c40f; color: #f1c40f; grid-column: span 2; width: 100%; border-radius: 10px; height: 35px; }

        #finisher-text {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 45px; font-weight: 900; font-style: italic; color: #f1c40f;
            text-shadow: 0 0 20px #000; pointer-events: none; display: none; z-index: 150;
        }

        #code-input {
            margin-top: 10px; background: #111; border: 1px solid #333; color: #0f0; 
            padding: 8px; font-family: 'Orbitron'; font-size: 10px; width: 200px; text-align: center;
            border-radius: 4px;
        }

        .loader { width: 40px; height: 40px; border: 4px solid #FFF; border-bottom-color: transparent; border-radius: 50%; animation: rotation 1s linear infinite; margin-bottom: 20px;}
        @keyframes rotation { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        .menu-btn { padding: 10px 20px; background: #222; border: 1px solid #444; color: white; border-radius: 5px; cursor: pointer; font-family: 'Orbitron'; margin: 5px; font-size: 11px; }
        .menu-btn:hover { background: #333; }
        .cancel-btn { background: #c0392b !important; border-color: #e74c3c !important; }
    </style>
</head>
<body>

<div id="finisher-text">NEXUS ERASED!</div>

<div id="start-screen">
    <h1 style="font-size: 24px; letter-spacing: 4px; margin-bottom: 5px;">NEXUS KNOCKOUT</h1>
    <p style="color: #f1c40f; margin-bottom: 15px; font-size: 11px;">RANKED SEASON 1</p>
    
    <div style="display: flex; gap: 8px; margin-bottom: 10px;">
        <button class="menu-btn" onclick="setMode('ranked')" id="mode-ranked" style="border-color: #f1c40f;">RANKED</button>
        <button class="menu-btn" onclick="setMode('spectate')" id="mode-spec">SPECTATE</button>
    </div>

    <input type="text" id="code-input" placeholder="ENTER ACCESS CODE" oninput="checkCode(this.value)">

    <p style="font-size: 9px; opacity: 0.6; margin-top: 10px;">SELECT YOUR FIGHTER</p>
    <div class="char-grid" id="main-char-grid"></div>
</div>

<div id="matchmaking-screen">
    <div class="loader"></div>
    <h2 id="match-status" style="font-size: 18px;">SEARCHING...</h2>
    <p id="match-timer">00:00</p>
    <p id="match-player" style="font-size: 10px; color: #aaa; margin-top: 10px;"></p>
    <div style="display: flex; flex-direction: column; gap: 10px; align-items: center;">
        <button id="ai-opt-btn" class="menu-btn" style="display: none; background: #27ae60;" onclick="forceAIStart()">PLAY VS AI (TRAINING)</button>
        <button class="menu-btn cancel-btn" onclick="cancelQueue()">CANCEL QUEUE</button>
    </div>
</div>

<div id="pause-screen">
    <h1 style="color: #f1c40f;">PAUSED</h1>
    <div style="display: flex; gap: 15px; margin-bottom: 30px;">
        <button onclick="togglePause()" style="padding: 15px 35px; background: #27ae60; color: white; border: none; font-weight: 900; border-radius: 30px; cursor: pointer; font-family: 'Orbitron';">RESUME</button>
        <button onclick="resetToMenu()" style="padding: 15px 35px; background: #e74c3c; color: white; border: none; font-weight: 900; border-radius: 30px; cursor: pointer; font-family: 'Orbitron';">EXIT</button>
    </div>
</div>

<div id="overlay">
    <div class="hud-container">
        <div class="player-card">
            <div id="p1-name" style="font-size: 11px; color: #00d2ff;">PLAYER</div>
            <div id="p1-damage" class="damage-val">0%</div>
            <div class="sp-bar"><div id="p1-sp" class="sp-fill"></div></div>
            <div id="p1-kos" style="font-size: 9px; margin-top: 5px;">KOs: 0/5</div>
        </div>
        
        <div id="pause-trigger" onclick="togglePause()">II PAUSE</div>

        <div class="player-card" style="border-bottom-color: #ff4d4d; text-align: right;">
            <div id="p2-name" style="font-size: 11px; color: #ff4d4d;">OPPONENT</div>
            <div id="p2-damage" class="damage-val">0%</div>
            <div class="sp-bar"><div id="p2-sp" class="sp-fill"></div></div>
            <div id="p2-kos" style="font-size: 9px; margin-top: 5px;">KOs: 0/5</div>
        </div>
    </div>
    <div id="game-controls" class="controls">
        <div id="joystick-outer"><div id="joystick-knob"></div></div>
        <div class="btn-group">
            <div id="btn-attack" class="btn" style="border-color: #e74c3c;">ATK</div>
            <div id="btn-jump" class="btn" style="border-color: #3498db;">JUMP</div>
            <div id="btn-special" class="btn btn-sp">SPECIAL</div>
        </div>
    </div>
</div>

<script>
    const CHARS = {
        prime:   { color: 0xff3e3e, speed: 0.16, jump: 0.55, power: 1.2, type: 'melee' },
        speedy:  { color: 0x00ccff, speed: 0.28, jump: 0.50, power: 0.6, type: 'melee' },
        shatter: { color: 0xe0e0e0, speed: 0.12, jump: 0.45, power: 1.8, type: 'melee' },
        pulse:   { color: 0x00ff88, speed: 0.15, jump: 0.55, power: 1.0, type: 'ranged' },
        gunner:  { color: 0x95a5a6, speed: 0.15, jump: 0.52, power: 0.8, type: 'ranged' },
        mage:    { color: 0x9b59b6, speed: 0.12, jump: 0.52, power: 0.9, type: 'ranged' },
        void:    { color: 0x000000, speed: 0.14, jump: 0.60, power: 5.0, type: 'boss', locked: true }, // UNBALANCED
        ninja:   { color: 0x222222, speed: 0.22, jump: 0.65, power: 0.8, type: 'melee' },
        beast:   { color: 0xd35400, speed: 0.14, jump: 0.58, power: 1.6, type: 'melee' },
        cyborg:  { color: 0x1abc9c, speed: 0.16, jump: 0.51, power: 1.4, type: 'ranged' },
        wraith:  { color: 0x8e44ad, speed: 0.18, jump: 0.60, power: 0.9, type: 'melee' },
        titan:   { color: 0x7f8c8d, speed: 0.10, jump: 0.48, power: 2.2, type: 'melee' },
        pyro:    { color: 0xe67e22, speed: 0.15, jump: 0.53, power: 1.3, type: 'ranged' },
        frost:   { color: 0x11e9ff, speed: 0.13, jump: 0.52, power: 1.0, type: 'ranged' },
        volt:    { color: 0xf1c40f, speed: 0.24, jump: 0.55, power: 0.8, type: 'melee' },
        shadow:  { color: 0x2c2c2c, speed: 0.18, jump: 0.60, power: 1.1, type: 'melee' },
        golem:   { color: 0x5d4037, speed: 0.08, jump: 0.45, power: 2.5, type: 'melee' },
        falcon:  { color: 0x2980b9, speed: 0.20, jump: 0.75, power: 0.7, type: 'melee' },
        knight:  { color: 0xbdc3c7, speed: 0.12, jump: 0.50, power: 1.5, type: 'melee' },
        archer:  { color: 0x27ae60, speed: 0.16, jump: 0.54, power: 0.9, type: 'ranged' },
        demon:   { color: 0xc0392b, speed: 0.15, jump: 0.56, power: 1.7, type: 'melee' },
        angel:   { color: 0xfff9c4, speed: 0.14, jump: 0.70, power: 0.8, type: 'ranged' },
        reaper:  { color: 0x1a1a1a, speed: 0.15, jump: 0.52, power: 1.8, type: 'melee' },
        samurai: { color: 0xff5252, speed: 0.18, jump: 0.53, power: 1.3, type: 'melee' },
        monk:    { color: 0xffccbc, speed: 0.22, jump: 0.68, power: 0.7, type: 'melee' },
        viking:  { color: 0xa1887f, speed: 0.11, jump: 0.51, power: 1.9, type: 'melee' },
        Alien:   { color: 0xb2ff59, speed: 0.16, jump: 0.60, power: 1.1, type: 'ranged' },
        Ghost:   { color: 0xe1f5fe, speed: 0.26, jump: 0.52, power: 0.5, type: 'melee' },
        Dragon:  { color: 0xbf360c, speed: 0.13, jump: 0.72, power: 1.6, type: 'ranged' },
        Glitch:  { color: 0x00e5ff, speed: 0.30, jump: 0.45, power: 0.9, type: 'melee' },
        Brawler: { color: 0xff1744, speed: 0.15, jump: 0.52, power: 1.8, type: 'melee' },
        Sniper:  { color: 0x455a64, height: 0.14, jump: 0.50, power: 1.4, type: 'ranged' },
        Mecha:   { color: 0x3f51b5, speed: 0.11, jump: 0.48, power: 2.1, type: 'ranged' },
        Witch:   { color: 0x6a1b9a, speed: 0.14, jump: 0.54, power: 1.1, type: 'ranged' },
        Rogue:   { color: 0x004d40, speed: 0.24, jump: 0.56, power: 0.9, type: 'melee' }
    };

    const MAPS = [
        { name: 'NEXUS', bg: 0x020205, platform: 0x111122, fog: 0x000, props: 0x333344 },
        { name: 'CYBERPUNK', bg: 0x1a0033, platform: 0x00ffff, fog: 0x1a0033, props: 0xff00ff },
        { name: 'BACKROOMS', bg: 0xd9c991, platform: 0xe0d4a0, fog: 0xd9c991, props: 0x8c7c4a },
        { name: 'MEDIEVAL', bg: 0x2d5a27, platform: 0x5d4037, fog: 0x2d5a27, props: 0x3e2723 },
        { name: 'SHADOW', bg: 0x000000, platform: 0x111111, fog: 0x000, props: 0x222222 },
        { name: 'ABANDONED', bg: 0x444444, platform: 0x222222, fog: 0x444444, props: 0x111111 },
        { name: 'MALL', bg: 0xffffff, platform: 0xdddddd, fog: 0xffffff, props: 0x88ccee }
    ];

    const SECRET_CODE = "919191012728438282838";
    const NAMES = ["ShadowKiller", "NinjaPro", "VoidLord69", "BotHunter", "TiltedTower", "GGWP_User", "NoobSlayer", "AlphaOne", "Z-End"];

    let scene, camera, renderer, fighters = [], gameRunning = false, isPaused = false;
    let timeScale = 1.0, projectiles = [], totalGlobalKOs = 0, currentMapIndex = 0;
    let nextMapKOs = 3, props = [];
    let currentMode = 'ranked';
    let selectedPlayerType = 'prime';
    let matchmakingInterval;
    let animationFrameId;

    const input = { x: 0, jump: false, attack: false, special: false };

    function checkCode(val) {
        if (val === SECRET_CODE) {
            CHARS.void.locked = false;
            populateUI();
            document.getElementById('code-input').style.borderColor = "#0f0";
            document.getElementById('code-input').style.boxShadow = "0 0 10px #0f0";
        }
    }

    function setMode(m) {
        currentMode = m;
        document.getElementById('mode-ranked').style.borderColor = m === 'ranked' ? '#f1c40f' : '#444';
        document.getElementById('mode-spec').style.borderColor = m === 'spectate' ? '#f1c40f' : '#444';
    }

    function populateUI() {
        const main = document.getElementById('main-char-grid');
        main.innerHTML = "";
        Object.keys(CHARS).forEach(k => {
            const isLocked = CHARS[k].locked;
            main.innerHTML += `<div class="char-card ${isLocked ? 'locked' : ''}" onclick="startFlow('${k}')">${k.toUpperCase()}</div>`;
        });
    }

    function startFlow(type) {
        if (CHARS[type].locked) return;
        selectedPlayerType = type;
        if (currentMode === 'spectate') {
            document.getElementById('start-screen').style.display = 'none';
            initScene(null);
        } else {
            startMatchmaking(type);
        }
    }

    function startMatchmaking(type) {
        document.getElementById('start-screen').style.display = 'none';
        document.getElementById('matchmaking-screen').style.display = 'flex';
        document.getElementById('ai-opt-btn').style.display = 'none';
        let current = 0;
        matchmakingInterval = setInterval(() => {
            current++;
            document.getElementById('match-timer').innerText = `00:${current.toString().padStart(2, '0')}`;
            if (current % 4 === 0) document.getElementById('match-player').innerText = `Looking for: ${NAMES[Math.floor(Math.random()*NAMES.length)]}`;
            if (current >= 15) document.getElementById('ai-opt-btn').style.display = 'block';
            if (current >= 45) forceAIStart();
        }, 1000);
    }

    function cancelQueue() {
        clearInterval(matchmakingInterval);
        document.getElementById('matchmaking-screen').style.display = 'none';
        document.getElementById('start-screen').style.display = 'flex';
    }

    function forceAIStart() {
        clearInterval(matchmakingInterval);
        document.getElementById('match-status').innerText = "MATCH READY!";
        setTimeout(() => {
            document.getElementById('matchmaking-screen').style.display = 'none';
            initScene(selectedPlayerType);
        }, 800);
    }

    function initScene(playerType) {
        document.getElementById('overlay').style.display = 'flex';
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.set(0, 12, 55);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        scene.add(new THREE.AmbientLight(0xffffff, 0.7));
        const sun = new THREE.DirectionalLight(0xffffff, 0.9); sun.position.set(20, 40, 20); scene.add(sun);

        buildMap(MAPS[0]);
        
        fighters = [];
        const roster = Object.keys(CHARS).filter(k => !CHARS[k].locked);
        if (playerType) {
            fighters.push(new Fighter(playerType, -18, false));
            fighters.push(new Fighter(roster[Math.floor(Math.random()*roster.length)], 18, true));
            document.getElementById('game-controls').style.display = 'flex';
        } else {
            fighters.push(new Fighter(roster[Math.floor(Math.random()*roster.length)], -18, true));
            fighters.push(new Fighter(roster[Math.floor(Math.random()*roster.length)], 18, true));
            document.getElementById('game-controls').style.display = 'none';
        }
        
        gameRunning = true;
        setupControls();
        animate();
    }

    function resetToMenu() {
        gameRunning = false;
        cancelAnimationFrame(animationFrameId);
        if(renderer) {
            document.body.removeChild(renderer.domElement);
            renderer.dispose();
            renderer = null;
        }
        document.getElementById('overlay').style.display = 'none';
        document.getElementById('pause-screen').style.display = 'none';
        document.getElementById('start-screen').style.display = 'flex';
        fighters = []; projectiles = []; totalGlobalKOs = 0; currentMapIndex = 0; isPaused = false; timeScale = 1.0;
    }

    function buildMap(mapData) {
        scene.children.filter(c => c.isMapPart).forEach(c => scene.remove(c));
        props.forEach(p => scene.remove(p));
        props = [];

        scene.background = new THREE.Color(mapData.bg);
        scene.fog = new THREE.Fog(mapData.bg, 20, 150);

        const mat = new THREE.MeshStandardMaterial({color: mapData.platform});
        const platform = new THREE.Mesh(new THREE.BoxGeometry(85, 4, 30), mat);
        platform.position.y = -2; platform.isMapPart = true;
        scene.add(platform);

        const propMat = new THREE.MeshStandardMaterial({color: mapData.props});
        for(let i=0; i<12; i++) {
            const box = new THREE.Mesh(new THREE.BoxGeometry(2.5, 2.5, 2.5), propMat);
            box.position.set(Math.random()*60-30, 1.25, Math.random()*10-5);
            box.isProp = true;
            scene.add(box);
            props.push(box);
        }
    }

    class Projectile {
        constructor(pos, dir, owner, color, isSpecial = false) {
            const size = isSpecial ? 2.5 : 0.7;
            this.mesh = new THREE.Mesh(new THREE.SphereGeometry(size), new THREE.MeshBasicMaterial({color, transparent: true, opacity: 0.8}));
            this.mesh.position.copy(pos);
            this.vel = new THREE.Vector3(dir * (isSpecial ? 0.8 : 1.5), 0, 0);
            this.owner = owner;
            this.isSpecial = isSpecial;
            scene.add(this.mesh);
            projectiles.push(this);
            setTimeout(() => this.destroy(), isSpecial ? 5000 : 2500);
        }
        update() {
            this.mesh.position.add(this.vel);
            fighters.forEach(f => {
                if (f !== this.owner && this.mesh.position.distanceTo(f.mesh.position) < (this.isSpecial ? 3.5 : 2.2)) {
                    this.owner.gainSP(this.isSpecial ? 0 : 15); 
                    f.takeHit(Math.sign(this.vel.x), this.isSpecial ? 2.5 : 0.85, this.owner);
                    if(!this.isSpecial) this.destroy();
                }
            });
        }
        destroy() {
            scene.remove(this.mesh);
            projectiles = projectiles.filter(p => p !== this);
        }
    }

    class Fighter {
        constructor(type, x, isBot) {
            this.type = type; this.isBot = isBot;
            this.stats = CHARS[type];
            this.damage = 0; this.totalKOs = 0; this.sp = 0;
            this.vel = new THREE.Vector3();
            this.onGround = false; this.facing = x < 0 ? 1 : -1; this.cd = 0; this.isFinishing = false;
            this.radius = 1.2; 
            
            this.mesh = new THREE.Group();
            const body = new THREE.Mesh(new THREE.BoxGeometry(1.8, 2.8, 1.4), new THREE.MeshStandardMaterial({color: this.stats.color}));
            body.position.y = 1.4; 
            this.mesh.add(body);
            
            if (this.stats.type === 'boss') {
                const aura = new THREE.Mesh(new THREE.SphereGeometry(10), new THREE.MeshBasicMaterial({color: 0x5500aa, transparent: true, opacity: 0.15, wireframe: true}));
                aura.position.y = 1.4;
                this.mesh.add(aura);
            }

            this.mesh.position.set(x, 10, 0);
            scene.add(this.mesh);
        }

        gainSP(amt) { this.sp = Math.min(100, this.sp + amt); }

        update() {
            if (isPaused || this.isFinishing) return;
            if (this.isBot) this.runAI(); else this.handleInput();

            // GRAVITY: Increased from 0.035 to 0.06 for better feel
            this.vel.y -= 0.06 * timeScale;
            this.mesh.position.add(this.vel.clone().multiplyScalar(timeScale));

            let groundY = 0;
            const onPlatform = Math.abs(this.mesh.position.x) < 42 && this.mesh.position.y >= groundY - 1.5;
            if (onPlatform && this.mesh.position.y <= groundY && this.vel.y <= 0) {
                this.mesh.position.y = groundY; this.vel.y = 0; this.onGround = true;
            } else { this.onGround = false; }

            // BOSS AURA REPEL
            if (this.stats.type === 'boss') {
                fighters.forEach(other => {
                    if (other === this) return;
                    const d = this.mesh.position.distanceTo(other.mesh.position);
                    if (d < 12) {
                        const pushDir = other.mesh.position.clone().sub(this.mesh.position).normalize();
                        // UNBALANCED REPEL: Scales with proximity
                        const force = (12 - d) * 0.8;
                        other.vel.x += pushDir.x * force;
                        other.vel.y += Math.max(0.2, pushDir.y) * force * 0.5;
                        other.damage += 0.1; // Passive burn
                    }
                });
            }

            fighters.forEach(other => {
                if (other === this) return;
                const dist = this.mesh.position.distanceTo(other.mesh.position);
                const minDist = this.radius + other.radius;
                if (dist < minDist) {
                    const force = (minDist - dist) * 0.25;
                    const diff = this.mesh.position.clone().sub(other.mesh.position).normalize();
                    this.vel.x += diff.x * force;
                }
            });

            this.vel.x *= 0.88; // Slightly more friction for grounded feel
            
            if (Math.abs(this.mesh.position.x) > 100 || this.mesh.position.y < -35 || this.mesh.position.y > 70) this.die();
            if (this.cd > 0) this.cd--;

            this.updateHUD();
        }

        handleInput() {
            if (Math.abs(input.x) > 0.1) { 
                this.vel.x += input.x * this.stats.speed; 
                this.facing = Math.sign(input.x); 
            }
            if (input.jump && this.onGround) { this.vel.y = this.stats.jump; input.jump = false; }
            if (input.attack && this.cd <= 0) this.attack(false);
            if (input.special && (this.sp >= 100 || this.stats.type === 'boss')) this.attack(true);
        }

        runAI() {
            const target = fighters.find(f => f !== this);
            if (!target) return;
            const dx = target.mesh.position.x - this.mesh.position.x;
            const dist = Math.abs(dx);
            const idealDist = (this.stats.type === 'ranged' ? 18 : 3.5);
            
            if (dist > idealDist + 1) {
                this.vel.x += Math.sign(dx) * this.stats.speed * 0.8;
                this.facing = Math.sign(dx);
            } else if (dist < idealDist - 1) {
                this.vel.x -= Math.sign(dx) * this.stats.speed * 0.8;
            }
            
            if (dist < 20 && this.cd <= 0 && Math.random() < 0.05) this.attack(false);
            if ((this.sp >= 100 || this.stats.type === 'boss') && dist < 15 && Math.random() < 0.02) this.attack(true);
            if (dist < 10 && target.mesh.position.y > this.mesh.position.y + 4 && this.onGround) this.vel.y = this.stats.jump;
        }

        attack(isSpecial) {
            this.cd = isSpecial ? 60 : (this.stats.type === 'ranged' ? 20 : 12);
            if(isSpecial && this.stats.type !== 'boss') this.sp = 0; 

            if (this.stats.type === 'ranged' || this.stats.type === 'boss' || isSpecial) {
                new Projectile(new THREE.Vector3(this.mesh.position.x, this.mesh.position.y + 1.4, 0), this.facing, this, isSpecial ? 0xaa00ff : this.stats.color, isSpecial);
            } else {
                const target = fighters.find(f => f !== this);
                if (target && this.mesh.position.distanceTo(target.mesh.position) < 6.5) {
                    this.gainSP(15);
                    target.takeHit(this.facing, this.stats.power, this);
                }
            }
        }

        takeHit(dir, pwr, attacker) {
            if (this.stats.type === 'boss') return; // IMMUNE

            const prevScale = timeScale;
            timeScale = 0.05;
            setTimeout(() => { timeScale = prevScale; }, 60);

            this.damage += Math.round(10 * pwr);
            const kb = (this.damage / 20) + 1.2;
            
            if (this.damage > 120 && Math.random() < 0.4) {
                attacker.playFinisher(this, dir, pwr, kb);
            } else {
                this.vel.x = dir * pwr * kb * 1.8;
                this.vel.y = pwr * kb * 0.8;
            }
        }

        playFinisher(target, dir, pwr, kb) {
            this.isFinishing = true; target.isFinishing = true; timeScale = 0.05;
            document.getElementById('finisher-text').style.display = 'block';
            setTimeout(() => {
                timeScale = 1.0; this.isFinishing = false; target.isFinishing = false;
                target.vel.x = dir * 80; target.vel.y = 35;
                document.getElementById('finisher-text').style.display = 'none';
            }, 1000);
        }

        die() {
            const killer = fighters.find(f => f !== this);
            if (killer) {
                killer.totalKOs++;
                totalGlobalKOs++;
                if (totalGlobalKOs >= nextMapKOs) {
                    currentMapIndex = (currentMapIndex + 1) % MAPS.length;
                    buildMap(MAPS[currentMapIndex]);
                    nextMapKOs += 4;
                }
                if (currentMode === 'ranked' && killer.totalKOs >= 5) {
                    setTimeout(() => {
                        const winMsg = killer.isBot ? "DEFEAT!" : "VICTORY!";
                        if(confirm(winMsg + " Play again?")) resetToMenu(); else resetToMenu();
                    }, 500);
                }
            }
            this.respawn();
        }

        respawn() {
            this.damage = 0; this.vel.set(0,0,0);
            this.mesh.position.set(this.facing < 0 ? 25 : -25, 25, 0);
        }

        updateHUD() {
            const isP1 = fighters[0] === this;
            const id = isP1 ? 'p1' : 'p2';
            document.getElementById(id+'-damage').innerText = this.damage + '%';
            const spFill = document.getElementById(id+'-sp');
            if (this.stats.type === 'boss') {
                spFill.style.width = '100%';
                spFill.style.background = '#aa00ff';
                spFill.style.boxShadow = '0 0 10px #aa00ff';
            } else {
                spFill.style.width = this.sp + '%';
                spFill.style.background = this.sp >= 100 ? '#fff' : 'linear-gradient(90deg, #f1c40f, #ff9f43)';
            }
            document.getElementById(id+'-name').innerText = this.type.toUpperCase();
            document.getElementById(id+'-kos').innerText = `KOs: ${this.totalKOs}/5`;
        }
    }

    function togglePause() {
        isPaused = !isPaused;
        document.getElementById('pause-screen').style.display = isPaused ? 'flex' : 'none';
    }

    function setupControls() {
        const outer = document.getElementById('joystick-outer');
        const knob = document.getElementById('joystick-knob');
        window.addEventListener('touchmove', (e) => {
            const t = e.touches[0];
            const r = outer.getBoundingClientRect(), cx = r.left + r.width/2, cy = r.top + r.height/2;
            const dx = t.clientX - cx, dy = t.clientY - cy, dist = Math.min(Math.sqrt(dx*dx + dy*dy), 40), angle = Math.atan2(dy, dx);
            knob.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
            input.x = Math.cos(angle) * (dist/40);
        }, {passive: false});
        window.addEventListener('touchend', () => { knob.style.transform = ''; input.x = 0; });
        document.getElementById('btn-jump').addEventListener('touchstart', (e) => { e.preventDefault(); input.jump = true; }, {passive: false});
        document.getElementById('btn-attack').addEventListener('touchstart', (e) => { e.preventDefault(); input.attack = true; }, {passive: false});
        document.getElementById('btn-special').addEventListener('touchstart', (e) => { e.preventDefault(); input.special = true; }, {passive: false});
        window.addEventListener('touchend', () => { input.jump = false; input.attack = false; input.special = false; });
    }

    function animate() {
        if (!gameRunning) return;
        animationFrameId = requestAnimationFrame(animate);
        if (!isPaused) {
            fighters.forEach(f => f.update());
            projectiles.forEach(p => p.update());
            if (fighters.length >= 2) {
                const midX = (fighters[0].mesh.position.x + fighters[1].mesh.position.x) / 2;
                camera.position.x += (midX - camera.position.x) * 0.1;
                camera.lookAt(midX, 6, 0);
            }
            props.forEach(p => {
                fighters.forEach(f => {
                    const dist = p.position.distanceTo(f.mesh.position);
                    if(dist < 3) p.position.x += (p.position.x - f.mesh.position.x) * 0.3;
                });
            });
        }
        if (renderer) renderer.render(scene, camera);
    }

    window.onload = populateUI;
</script>
</body>
</html>
